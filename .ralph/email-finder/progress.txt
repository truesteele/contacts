# Ralph Progress Log
Loop: email-finder
Started: 2026-02-24
---

## Codebase Patterns
- DB connection: psycopg2 with `get_db_conn()`, DictCursor for row access
- CLI: argparse with --dry-run, --limit, test flags
- OpenAI: `responses.parse()` with pydantic models, `gpt-5-mini`, 150 workers
- Env vars: SUPABASE_DB_PASSWORD, OPENAI_APIKEY, ZEROBOUNCE_API_KEY
- Progress: print every N contacts with elapsed/ETA
- Reference script: `discover_emails_v2.py` has EmailVerification pydantic model

---

## Iteration Log

### Iteration 1: US-001 — Domain Discovery Module
**Date:** 2026-02-24
**Status:** COMPLETE

**What was built:**
- Created `scripts/intelligence/find_emails.py` with full CLI structure
- `company_to_domains()` function with 3-tier lookup:
  1. Hardcoded map (80+ known companies incl. big tech, consulting, finance, universities)
  2. Prefix matching for subsidiaries (e.g., "Duke University - The Fuqua School of Business" → duke.edu)
  3. Generic fallback: strip suffixes, generate slug.com/.org/.io/.co variants
- DNS MX record check with caching (`check_mx()`) — 3s timeout, results cached in `_mx_cache`
- `--test-domains` CLI flag tests 10 sample contacts from DB

**Test results:**
- 10/10 contacts got domains (100% hit rate)
- Known companies resolved instantly (Google, Year Up, Datadog, Xero, TikTok)
- Generic fallback worked: "Next Step Living, Inc" → nextstepliving.com, nextstepliving.org
- Edge cases passed: empty strings, None, long names with descriptions, suffixes
- MX check took 0.4s for 14 unique domains (fast with caching)

**Key decisions:**
- 80+ entries in KNOWN_COMPANY_DOMAINS (much more than the 20+ minimum)
- MX cache avoids re-querying same domains across contacts
- Installed `dnspython` into .venv
- Placeholder stubs for --test-perms, --test-verify, --test-validate (future stories)

### Iteration 2: US-002 — Email Permutation Generator
**Date:** 2026-02-24
**Status:** COMPLETE

**What was built:**
- `generate_permutations(first, last, domain)` — returns 8-12 candidate emails per contact
- `_clean_name_part()` — strips suffixes (Jr, III, PhD, etc.), apostrophes, quotes, parentheticals, collapses spaces
- `_split_hyphenated()` — handles hyphenated names with 3 variants (full, joined, first-part)
- `NAME_SUFFIXES` regex — comprehensive pattern for Jr, III, PhD, MD, MBA, etc.
- `test_perms()` — tests 5 real DB contacts + 5 synthetic edge cases

**Permutation patterns (in priority order):**
1. first.last, firstlast, first_last (most common corporate)
2. flast, first.l, firstl (initial-based)
3. f.last, last.first, lastf (reverse patterns)
4. first (founders / small companies)
5. Hyphenated variants: short-first.last, short-firstlast (if applicable)

**Edge cases handled:**
- Hyphenated first: "Marie-Ange" → marieange, marie variants (12 perms)
- Suffixes: "Smith III" → "smith" (III stripped cleanly)
- Multi-word last: "de la Cruz" → "delacruz" (spaces collapsed)
- Apostrophes: "O'Brien" → "obrien"
- Single initial: "A." → "a" (8 perms, fewer patterns possible)
- Nicknames: "Jen" used as-is (no expansion needed)

**Test results:**
- 5/5 DB contacts: 10 permutations each (standard names)
- Edge cases: 8-12 permutations depending on name complexity
- All emails have valid format (no spaces, no special chars in local part)

**Key decisions:**
- Spaces in multi-word names are collapsed (not hyphenated) — "de la Cruz" → "delacruz" — because most email systems don't allow spaces
- Apostrophes stripped entirely — "O'Brien" → "obrien" — consistent with most corporate patterns
- Hyphenated names produce extra variants (marie.dupont, mariedupont) to catch both conventions

### Iteration 3: US-003 — ZeroBounce Integration
**Date:** 2026-02-24
**Status:** COMPLETE

**What was built:**
- `verify_email(email_addr)` — single email verification via ZeroBounce API with retry logic
- `verify_emails_batch(emails, max_workers)` — concurrent verification using ThreadPoolExecutor
- `pick_best_result(results)` — selects best email from batch results (valid > catch-all, scored by activity recency)
- `check_zerobounce_credits()` — credit balance check before runs
- `_activity_score(result)` — ranks results by active_in_days for recency
- `get_credits_used()` — session-level credit tracking (unknown results are free)
- `test_verify()` — tests 3 individual emails + batch verification + pick_best_result
- CATCH_ALL_DOMAINS set for known catch-all companies (Google, Amazon, Meta, etc.)
- TRANSIENT_SUBSTATUSES set for retry-eligible sub-statuses

**Retry logic:**
- Exponential backoff: 2s, 4s for transient errors (greylisted, mail_server_temporary_error, etc.)
- 429 rate limit: wait 65s (1-min block + 5s buffer)
- Request timeout: 30s per call, retried up to 2 times
- max_retries=2 by default (3 total attempts)

**Test results (3 individual + 3 batch = 6 credits used):**
- `justinrsteele@gmail.com`: status=valid, free_email=True, smtp_provider=google
- `definitelynotarealemailaddress99999@gmail.com`: status=invalid, sub_status=mailbox_not_found
- `test@google.com`: status=abuse (ZeroBounce AI flagged as abuse address, not catch-all)
- Batch verification: 3 emails concurrently, pick_best_result correctly chose the valid email
- Credits: started at 1274, used 6 (3 single + 3 batch = 6; unknown results would be free but all were non-unknown)
- Total time: 2.3s for 3 sequential + batch of 3

**Key decisions:**
- `requests` library used (already in venv, simpler than aiohttp for ThreadPoolExecutor pattern)
- max_workers=50 default for ZeroBounce (conservative, well under 80K/10sec limit)
- Credit tracking via module-level `_credits_used` counter, incremented only for non-unknown results
- pick_best_result prefers valid > catch-all, uses active_in_days for tiebreaking

**Key findings:**
- ZeroBounce active_in_days returns None for many results (gmail valid, gmail invalid, google.com abuse all returned None)
- google.com returns "abuse" for test@ (not catch-all) — their AI detection is sophisticated
- do_not_mail/global_suppression for obviously fake example.com addresses
- API response time: ~0.7s per single call, batch of 3 took similar time with concurrency

### Iteration 4: US-004 — GPT-5 Mini Validation + Scoring
**Date:** 2026-02-24
**Status:** COMPLETE

**What was built:**
- `EmailVerification` pydantic model — reused from discover_emails_v2.py (is_match, confidence, reasoning, email_type)
- `is_obvious_match(contact, email, zb_result)` — auto-accept logic that skips LLM:
  - Requires: full name in email local part + valid ZB status + (domain matches company OR personal domain)
  - Uses regex slug matching for company-domain comparison
- `validate_with_llm(openai_client, contact, email, zb_result)` — GPT-5 mini structured output validation:
  - Prompt includes: name, company, title, LinkedIn, ZB status/sub_status, free_email, active_in_days, smtp_provider
  - Rules: reject stale employer domains, accept personal with good match, skeptical on catch-all, stricter for common names
  - Retry logic: exponential backoff (1s, 2s), 2 retries
- `validate_emails_batch(openai_client, tasks, max_workers=150)` — concurrent LLM validation using ThreadPoolExecutor
- `PERSONAL_DOMAINS` set — 15 common free email domains for personal email detection
- `test_validate()` — 3 mock scenarios:
  1. Obvious match: sarah.chen@stripe.com for Sarah Chen at Stripe → is_match=True, obvious=True
  2. Stale employer: marcus.johnson@google.com for Marcus Johnson at Anthropic → is_match=False, obvious=False
  3. Personal email: elena.rodriguez@gmail.com for Elena Rodriguez at McKinsey → is_match=True, obvious=True

**Test results:**
- 3/3 LLM validations matched expected outcomes
- is_obvious_match correctly identified all 3 cases
- LLM confidence: 92 (obvious work), 90 (stale reject), 85 (personal accept)
- LLM reasoning was detailed and rule-adherent in all cases
- Total time: 28.1s for 3 sequential LLM calls (~9.4s per call)
- No API errors, no retries needed

**Key decisions:**
- is_obvious_match uses slug-based company-domain matching (strip non-alphanumeric, substring check both directions)
- Personal domains get auto-accepted by is_obvious_match if name matches + valid ZB status (no LLM needed)
- LLM prompt explicitly calls out catch-all skepticism and common name strictness
- validate_emails_batch supports 150 workers (matching existing GPT concurrency pattern)
- email_type output: personal | work | unknown — useful for downstream priority sorting
